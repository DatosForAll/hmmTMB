% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/hmm.R
\name{HMM}
\alias{HMM}
\title{R6 class for hidden Markov model}
\description{
R6 class for hidden Markov model

R6 class for hidden Markov model
}
\details{
Encapsulates the observation and hidden state models for a hidden
Markov model.

Compute pseudo-residuals for the fitted model. If the fitted model
is the "true" model, the pseudo-residuals follow a standard normal distribution.
Deviations from normality suggest lack of fit.
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-new}{\code{HMM$new()}}
\item \href{#method-obs}{\code{HMM$obs()}}
\item \href{#method-hidden}{\code{HMM$hidden()}}
\item \href{#method-out}{\code{HMM$out()}}
\item \href{#method-tmb_obj}{\code{HMM$tmb_obj()}}
\item \href{#method-tmb_rep}{\code{HMM$tmb_rep()}}
\item \href{#method-states}{\code{HMM$states()}}
\item \href{#method-coeff_fe}{\code{HMM$coeff_fe()}}
\item \href{#method-coeff_re}{\code{HMM$coeff_re()}}
\item \href{#method-lambda}{\code{HMM$lambda()}}
\item \href{#method-update_par}{\code{HMM$update_par()}}
\item \href{#method-vcomp}{\code{HMM$vcomp()}}
\item \href{#method-par}{\code{HMM$par()}}
\item \href{#method-suggest_initial}{\code{HMM$suggest_initial()}}
\item \href{#method-set_priors}{\code{HMM$set_priors()}}
\item \href{#method-priors}{\code{HMM$priors()}}
\item \href{#method-iters}{\code{HMM$iters()}}
\item \href{#method-stan}{\code{HMM$stan()}}
\item \href{#method-llk}{\code{HMM$llk()}}
\item \href{#method-edf}{\code{HMM$edf()}}
\item \href{#method-setup}{\code{HMM$setup()}}
\item \href{#method-mcmc}{\code{HMM$mcmc()}}
\item \href{#method-fit}{\code{HMM$fit()}}
\item \href{#method-mle}{\code{HMM$mle()}}
\item \href{#method-forward_backward}{\code{HMM$forward_backward()}}
\item \href{#method-cond}{\code{HMM$cond()}}
\item \href{#method-pseudores}{\code{HMM$pseudores()}}
\item \href{#method-viterbi}{\code{HMM$viterbi()}}
\item \href{#method-sample_states}{\code{HMM$sample_states()}}
\item \href{#method-state_probs}{\code{HMM$state_probs()}}
\item \href{#method-post_coeff}{\code{HMM$post_coeff()}}
\item \href{#method-post_linpred}{\code{HMM$post_linpred()}}
\item \href{#method-post_fn}{\code{HMM$post_fn()}}
\item \href{#method-predict}{\code{HMM$predict()}}
\item \href{#method-simulate}{\code{HMM$simulate()}}
\item \href{#method-gof}{\code{HMM$gof()}}
\item \href{#method-plot_ts}{\code{HMM$plot_ts()}}
\item \href{#method-plot}{\code{HMM$plot()}}
\item \href{#method-formulation}{\code{HMM$formulation()}}
\item \href{#method-print}{\code{HMM$print()}}
\item \href{#method-clone}{\code{HMM$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-new"></a>}}
\if{latex}{\out{\hypertarget{method-new}{}}}
\subsection{Method \code{new()}}{
Create new HMM object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$new(file = NULL, obs = NULL, hidden = NULL, init = NULL, fixpar = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{file}}{path to specification file for HMM}

\item{\code{obs}}{Observation object}

\item{\code{hidden}}{MarkovChain object}

\item{\code{init}}{HMM object to initialize parameters with}

\item{\code{fixpar}}{a named list of parameters in coeff_fe that you want fixed 
(set to NA) or pool into common values (using factor levels)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A new HMM object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-obs"></a>}}
\if{latex}{\out{\hypertarget{method-obs}{}}}
\subsection{Method \code{obs()}}{
Observation object for this model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$obs()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-hidden"></a>}}
\if{latex}{\out{\hypertarget{method-hidden}{}}}
\subsection{Method \code{hidden()}}{
MarkovChain object for this model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$hidden()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-out"></a>}}
\if{latex}{\out{\hypertarget{method-out}{}}}
\subsection{Method \code{out()}}{
Output of optimiser after model fitting
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$out()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-tmb_obj"></a>}}
\if{latex}{\out{\hypertarget{method-tmb_obj}{}}}
\subsection{Method \code{tmb_obj()}}{
Model object created by TMB. This is the output of 
the TMB function \code{MakeADFun}, and it is a list including elements
\itemize{
  \item{\code{fn}}{Objective function}
  \item{\code{gr}}{Gradient function of fn}
  \item{\code{par}}{Vector of initial parameters on working scale}
}
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$tmb_obj()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-tmb_rep"></a>}}
\if{latex}{\out{\hypertarget{method-tmb_rep}{}}}
\subsection{Method \code{tmb_rep()}}{
Output of the TMB function \code{sdreport}, which includes 
estimates and standard errors for all model parameters.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$tmb_rep()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-states"></a>}}
\if{latex}{\out{\hypertarget{method-states}{}}}
\subsection{Method \code{states()}}{
Vector of estimated states, after \code{viterbi} has
been run
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$states()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-coeff_fe"></a>}}
\if{latex}{\out{\hypertarget{method-coeff_fe}{}}}
\subsection{Method \code{coeff_fe()}}{
Coefficients for fixed effect parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$coeff_fe()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-coeff_re"></a>}}
\if{latex}{\out{\hypertarget{method-coeff_re}{}}}
\subsection{Method \code{coeff_re()}}{
Coefficients for random effect parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$coeff_re()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-lambda"></a>}}
\if{latex}{\out{\hypertarget{method-lambda}{}}}
\subsection{Method \code{lambda()}}{
Smoothness parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$lambda()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-update_par"></a>}}
\if{latex}{\out{\hypertarget{method-update_par}{}}}
\subsection{Method \code{update_par()}}{
Update parameters stored inside model object
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$update_par(par_list = NULL, iter = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{par_list}}{a list for coeff_f(r)e_obs, coeff_f(r)e_hid, log_delta, 
log_lambda_hid log_lambda_obs}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-vcomp"></a>}}
\if{latex}{\out{\hypertarget{method-vcomp}{}}}
\subsection{Method \code{vcomp()}}{
Variance components of smooth terms

This function transforms the smoothness parameter of
each smooth term into a standard deviation, given by 
SD = 1/sqrt(lambda). It is particularly helpful to get the
standard deviations of independent normal random effects.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$vcomp()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-par"></a>}}
\if{latex}{\out{\hypertarget{method-par}{}}}
\subsection{Method \code{par()}}{
Model parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$par(t = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{t}}{returns parameters at time t, default is t = 1}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A list with elements:
\itemize{
  \item{\code{obspar}}{Parameters of observation model}
  \item{\code{tpm}}{Transition probability matrix of hidden state model}
}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-suggest_initial"></a>}}
\if{latex}{\out{\hypertarget{method-suggest_initial}{}}}
\subsection{Method \code{suggest_initial()}}{
Suggest initial parameters for the model based on kmeans
clustering
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$suggest_initial()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
list of initial parameters for each observation variable 
Set priors for coefficients
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-set_priors"></a>}}
\if{latex}{\out{\hypertarget{method-set_priors}{}}}
\subsection{Method \code{set_priors()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$set_priors(new_priors = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{new_priors}}{is a list of matrices for optionally 
coeff_fe_obs, coeff_fe_hid, log_lambda_obs log_lambda_hid 
each matrix has two rows (first row = mean, second row = sd) 
specifying parameters for Normal priors}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-priors"></a>}}
\if{latex}{\out{\hypertarget{method-priors}{}}}
\subsection{Method \code{priors()}}{
Extract stored priors
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$priors()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-iters"></a>}}
\if{latex}{\out{\hypertarget{method-iters}{}}}
\subsection{Method \code{iters()}}{
Iterations from stan MCMC fit
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$iters(type = "response")}\if{html}{\out{</div>}}
}

\subsection{Returns}{
see output of as.matrix in stan
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-stan"></a>}}
\if{latex}{\out{\hypertarget{method-stan}{}}}
\subsection{Method \code{stan()}}{
fitted stan object from MCMC fit
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$stan()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
the stanfit object
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-llk"></a>}}
\if{latex}{\out{\hypertarget{method-llk}{}}}
\subsection{Method \code{llk()}}{
Log-likelihood at current parameters
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$llk()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Log-likelihood
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-edf"></a>}}
\if{latex}{\out{\hypertarget{method-edf}{}}}
\subsection{Method \code{edf()}}{
Compute effective degrees of freedom
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$edf()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-setup"></a>}}
\if{latex}{\out{\hypertarget{method-setup}{}}}
\subsection{Method \code{setup()}}{
TMB setup

This creates an attribute \code{tmb_obj}, which can be used to 
evaluate the negative log-likelihood function.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$setup(silent = TRUE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{silent}}{Logical. If TRUE, all tracing outputs are hidden (default).}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mcmc"></a>}}
\if{latex}{\out{\hypertarget{method-mcmc}{}}}
\subsection{Method \code{mcmc()}}{
Fit model using tmbstan
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$mcmc(..., silent = FALSE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-fit"></a>}}
\if{latex}{\out{\hypertarget{method-fit}{}}}
\subsection{Method \code{fit()}}{
Model fitting

The negative log-likelihood of the model is minimised using the
function \code{optim}. TMB uses the Laplace approximation to integrate 
the random effects out of the likelihood.

After the model has been fitted, the output of \code{optim} can be
accessed using the method \code{out}.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$fit(silent = FALSE, ...)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{silent}}{Logical. If FALSE, all tracing outputs are hidden (default).}

\item{\code{...}}{other arguments to optimx which is used to optimise likelihood, 
see ?optimx}
}
\if{html}{\out{</div>}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-mle"></a>}}
\if{latex}{\out{\hypertarget{method-mle}{}}}
\subsection{Method \code{mle()}}{
Get maximum likelihood estimates once model fitted
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$mle()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
list of maximum likelihood estimates as described as
input for the function update_par()
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-forward_backward"></a>}}
\if{latex}{\out{\hypertarget{method-forward_backward}{}}}
\subsection{Method \code{forward_backward()}}{
Forward-backward algorithm
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$forward_backward()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
log-forward and log-backward probabilities
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-cond"></a>}}
\if{latex}{\out{\hypertarget{method-cond}{}}}
\subsection{Method \code{cond()}}{
Compute conditional cumulative distribution functions
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$cond(ngrid = 100, silent = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{ngrid}}{how many cells on the grid that CDF is computed on}

\item{\code{silent}}{if TRUE then no messages are printed}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
cdfs on grid for each variable
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-pseudores"></a>}}
\if{latex}{\out{\hypertarget{method-pseudores}{}}}
\subsection{Method \code{pseudores()}}{
Pseudo-residuals
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$pseudores()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Matrix of pseudo-residuals, with one row for each response variable
and one column for each observation
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-viterbi"></a>}}
\if{latex}{\out{\hypertarget{method-viterbi}{}}}
\subsection{Method \code{viterbi()}}{
Viterbi algorithm
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$viterbi()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
Most likely state sequence
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-sample_states"></a>}}
\if{latex}{\out{\hypertarget{method-sample_states}{}}}
\subsection{Method \code{sample_states()}}{
Sample posterior state sequences using forward-filtering
backward-sampling
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$sample_states(nsamp = 1, full = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{nsamp}}{number of samples to produce}

\item{\code{full}}{if TRUE and model fit by mcmc then parameter estimates are 
sampled from the posterior samples before simulating each sequence}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
matrix where each column is a different sample of state sequences
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-state_probs"></a>}}
\if{latex}{\out{\hypertarget{method-state_probs}{}}}
\subsection{Method \code{state_probs()}}{
Compute posterior probability of being in each state
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$state_probs()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
matrix with a row for each observation and a column for each state
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-post_coeff"></a>}}
\if{latex}{\out{\hypertarget{method-post_coeff}{}}}
\subsection{Method \code{post_coeff()}}{
Posterior sampling for model coefficients
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$post_coeff(n_post)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_post}}{Number of posterior samples}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Matrix with one column for each coefficient and one row
for each posterior draw
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-post_linpred"></a>}}
\if{latex}{\out{\hypertarget{method-post_linpred}{}}}
\subsection{Method \code{post_linpred()}}{
Posterior sampling for linear predictor
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$post_linpred(n_post)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_post}}{Number of posterior samples}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Matrix with one column for each predictor and one row
for each posterior draw
Create posterior simulations of a function of a model component
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-post_fn"></a>}}
\if{latex}{\out{\hypertarget{method-post_fn}{}}}
\subsection{Method \code{post_fn()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$post_fn(fn, n_post, comp = NULL, ..., level = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{fn}}{the function which takes a vector of linear predictors as input
and produces either a scalar or vector output}

\item{\code{n_post}}{number of posterior simulations}

\item{\code{comp}}{is "obs" for observation model linear predictor, "hidden" for
hidden model linear predictor}

\item{\code{level}}{confidence interval level, default is 95\%}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
a vector (for scalar outputs of fn) or a matrix (for vector outputs)
with a column for each simulation 
Predict estimates from a fitted model
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-predict"></a>}}
\if{latex}{\out{\hypertarget{method-predict}{}}}
\subsection{Method \code{predict()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$predict(name, t = 1, newdata = NULL, level = 0, n_post = 0)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{which estimates to predict? Options include 
transition probability matrices "tpm", 
stationary distributions "delta", or 
observation distribution parameters "obspar"}

\item{\code{t}}{time points to predict at}

\item{\code{newdata}}{new dataframe to use for prediction}

\item{\code{level}}{if greater than zero, then produce confidence intervals with this level, e.g. CI = 0.95
will produce 95\% confidence intervals}

\item{\code{n_post}}{if greater than zero then n_post posterior samples are produced}

\item{\code{...}}{other arguments to the respective functions for hidden$tpm, hidden$delta, obs$par}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
named array of predictions and confidence interval, if requested
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-simulate"></a>}}
\if{latex}{\out{\hypertarget{method-simulate}{}}}
\subsection{Method \code{simulate()}}{
Simulate from hidden Markov model
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$simulate(n, data = NULL, silent = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n}}{Number of time steps to simulate}

\item{\code{data}}{Optional data frame including covariates}

\item{\code{silent}}{if TRUE then no messages are printed}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
Data frame including columns of data (if provided), and simulated
data variables
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-gof"></a>}}
\if{latex}{\out{\hypertarget{method-gof}{}}}
\subsection{Method \code{gof()}}{
Compute goodness-of-fit statistics using simulation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$gof(gof_fn, nsims = 100, full = FALSE, silent = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{gof_fn}}{goodness-of-fit function which accepts "data" as input
and returns a statistic: either a vector or a single number.}

\item{\code{nsims}}{number of simulations to perform}

\item{\code{full}}{if model fit with MCMC then full set to TRUE will sample from
posterior for each simulation}

\item{\code{silent}}{Logical. If FALSE, simulation progress is shown. 
(Default: TRUE)}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
List with elements:
\begin{itemize}
\item{obs_stat} Vector of values of goodness-of-fit statistics for the
observed data
\item{stats} Matrix of values of goodness-of-fit statistics for the
simulated data sets (one row for each statistic, and one column for each
simulation)
\item{plot} ggplot object
\end{itemize}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot_ts"></a>}}
\if{latex}{\out{\hypertarget{method-plot_ts}{}}}
\subsection{Method \code{plot_ts()}}{
Time series plot coloured by states

Creates a plot of the data coloured by the most likely state sequence,
as estimated by the Viterbi algorithm. If one variable name is passed
as input, it is plotted against time. If two variables are passed, they
are plotted against each other.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$plot_ts(var1, var2 = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{var1}}{Name of the variable to plot.}

\item{\code{var2}}{Optional name of a second variable, for 2-d plot.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
A ggplot object
Plot a model component
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-plot"></a>}}
\if{latex}{\out{\hypertarget{method-plot}{}}}
\subsection{Method \code{plot()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$plot(name, var = NULL, covs = NULL, i = NULL, j = NULL, n_grid = 50)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{name}}{name of model component: tpm, delta, or obspar}

\item{\code{var}}{covariate to plot on x-axis}

\item{\code{covs}}{Optional data frame with a single row and one column
for each covariate, giving the values that should be used. If this is
not specified, the mean value is used for numeric variables, and the
first level for factor variables.}

\item{\code{i}}{if plotting tpm then rows of tpm, if plotting delta then state, 
if plotting obspar then indices of parameter to plot}

\item{\code{j}}{if plotting tpm then cols of tpm to plot, if plotting delta then
ignored, if plotting obspar then indices of states to plot}

\item{\code{n_grid}}{coarseness of grid over x-axis to create}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
desired plot
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-formulation"></a>}}
\if{latex}{\out{\hypertarget{method-formulation}{}}}
\subsection{Method \code{formulation()}}{
Print model formulation
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$formulation()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-print"></a>}}
\if{latex}{\out{\hypertarget{method-print}{}}}
\subsection{Method \code{print()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$print()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-clone"></a>}}
\if{latex}{\out{\hypertarget{method-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{HMM$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
