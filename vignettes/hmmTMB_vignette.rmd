---
title: "hmmTMB vignette"
author: "ThÃ©o Michelot, Richard Glennie"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
bibliography: refs.bib
vignette: >
  %\VignetteIndexEntry{hmmTMB vignette}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
message = FALSE, error = FALSE, warning = FALSE,
comment = NA
)
```

```{r set-seed, echo = FALSE}
library(hmmTMB)
set.seed(905)
```

# Introduction

The package hmmTMB implements hidden Markov models (HMMs) with flexible covariate dependence in all model parameters. In this document, we briefly describe the structure of the package, and illustrate its use with several examples. For general background on HMMs, see @zucchini2016 and, for a presentation of HMMs in the context of ecological studies, see @mcclintock2020.

HMMs are time series models involving two processes: an unobserved state process $(S_t)$ specified as a Markov chain, and an observation process $(Z_t)$. At each time $t = 1, 2, \dots$, the distribution of the observation $Z_t$ depends on the value $S_t$ of the state process. There are therefore two sets of parameters:

  - the state process is formulated in terms of a transition probability matrix (and an initial distribution);
  
  - the observation process is formulated in terms of the state-dependent parameters of the observation distributions. 
  
In hmmTMB, the parameters of the state process and of the observation process can depend on covariates, including linear fixed effects, smooth covariate effects using splines, and i.i.d. normal random effects.

# Package structure

The package hmmTMB uses the R6 framework for object-oriented programming (@chang2019), and it is based on three main classes:

  - MarkovChain: model for state process, including formulas for the transition probabilities
  
  - Observation: model for observation process, including state-dependent distributions, and formulas for the state-dependent observation parameters
  
  - Hmm: contains a state process model (i.e., a MarkovChain object) and an observation model (i.e., an Observation object).
  
Model specification, model fitting and model visualisation can all be performed by manipulating objects from those three classes. Following the R6 syntax, an object is created with something like
```{r r6-new}
hidden <- MarkovChain$new(n_states = 2)
```
This line of code defines a hidden state model with 2 states and no covariate dependence. Once an object is created, various methods (i.e., functions) can be called to manipulate it, using the following syntax:
```{r r6-method}
hidden$formulas()
```

# Example 1: Elk movement analysis

We illustrate the use of the package on a data set of elk movement (from @morales2004), accessible through the moveHMM package. In this example, we showcase the use of smoothing splines to model the relationship between model parameters and covariates.

```{r load-packs}
# Load packages
library(hmmTMB)
library(moveHMM)
```

In analyses of animal movement, the step lengths and turning angles are modelled to capture features of the speed and directionality of the movement. We derive those variables from the location using the function prepData in moveHMM.

```{r prep-data}
tracks <- prepData(elk_data, type = "UTM", coordNames = c("Easting", "Northing"))

head(tracks)
```

The data set now has columns for the coordinates (x and y), the step lengths and turning angles, the ID (track identifier), and a covariate (distance to water). hmmTMB doesn't allow for zero inflation for observation distributions with positive support (e.g. gamma), so we jitter step lengths with value zero.

```{r jitter}
indz <- which(tracks$step == 0)
tracks$step[indz] <- runif(length(indz), 0, 1)
```

We create an HmmData object from the data frame. It should include columns for ID if necessary, as well as for any response variables and covariates included in the model.
```{r hmmdata-new}
data <- HmmData$new(data = tracks)
```

The class Observation encapsulates the observation process model of the hidden Markov model. To create an object of that class, we need to specify distributions for the response variables, as well as initial parameter values. We could also include covariate dependence in the parameters of the observation distributions. We use gamma distributions for the step lengths, and von Mises distributions for the turning angles.

```{r obs-new}
# Number of states of the HMM 
n_states <- 2

# Observation distributions: gamma for the step lengths, and
# von Mises for the turning angles
dists <- list(step = dist_gamma, angle = dist_vm)

# Initial parameters
mean0 <- c(300, 3000)
sd0 <- c(400, 4000)
par0_obs <- list(step = list(shape = mean0^2/sd0^2,
                             scale = sd0^2/mean0),
                 angle = list(mu = c(3, 0),
                              kappa = c(0.2, 1)))

# Create Observation object
obs <- Observation$new(data = data, dists = dists, 
                       n_states = n_states, par = par0_obs)
```

Similarly, we need to create an object of the class MarkovChain for the hidden process model, encapsulating the formulas and parameter values. Here, we formulate the transition probabilities as functions of the distance to water covariate, with smoothing splines specified using the syntax from the package mgcv (@wood2017).

```{r hid-new}
# Formula for transition probabilities
formula <- ~ s(dist_water, k = 5, bs = "ts")

# Create MarkovChain object
hid <- MarkovChain$new(n_states = n_states, 
                       structure = formula,
                       data = data)
```

Combining the MarkovChain and Observation object, we create an object of the Hmm class.

```{r hmm-new}
hmm <- Hmm$new(obs = obs, hidden = hid)
```

We fit the model with the method fit, and print the output of the optimiser with res. It contains the parameters estimates (fixed effects), the value of the objective function at the optimum, and diagnostics from the optimiser.

```{r hmm-fit}
hmm$fit()

hmm$out()
```

We can get confidence intervals for the parameters (on the working scale) with the method CI_wpar. By default, it returns 95\% confidence intervals, but the argument level can be specified for different confidence levels.

```{r hmm-ci}
hmm$CI_coeff()
```

The method viterbi implements the Viterbi algorithm, to estimate the most likely state sequence.
```{r hmm-viterbi}
states <- hmm$viterbi()

head(states)
```

Various plotting functions are provided to visualise a fitted model. Using the method Observation\$plot_dist, we can plot histograms of the observed data, overlaid with the estimated state-dependent probability density functions.

```{r plot-dist}
# Proportion of states in Viterbi sequence, to weigh pdfs
w <- table(states)/length(states)
obs$plot_dist("step", weights = w)
obs$plot_dist("angle", weights = w)
```

We can plot the data coloured by the Viterbi-decoded states. All plotting functions return ggplot objects, and can easily be edited using ggplot commands, e.g.\ to change axis labels or colours.

```{r plot-ts}
hmm$plot_ts("step")
hmm$plot_ts("x", "y") + coord_equal() + geom_point(size = 0.5)
```

The function plot_tpm creates graphs of the transition probabilities as functions of a covariate, here distance to water.

```{r plot-tpm}
hmm$plot_tpm("dist_water") + xlab("Distance to water (m)")
```

With the function plot_stat_dist, we can visualise the stationary state probabilities as functions of the distance to water.

```{r plot-stat}
hmm$plot_stat_dist("dist_water") + xlab("Distance to water (m)")
```

We can simulate from the fitted model with the method simulate, for example to check how well the model captures features of the real data. Here, we simulate step lengths and turning angles from the model.

```{r hmm-sim, results = 'hide'}
# Number of simulated realisations
n_sim <- 500
# Data frame of covariate values for simulation
new_covs <- data.frame(dist_water = sample(tracks$dist_water, 
                                           replace = TRUE, 
                                           size = n_sim))

# Simulate from fitted model
sim_data <- hmm$simulate(n = n_sim, data = new_covs)
```

The output is a data frame with the same columns as the input, plus columns for the simulated variables, and a column for the simulated states.

```{r hmm-sim-2}
head(sim_data)
```

We then derive the corresponding locations to visualise the simulated movement trajectory.

```{r hmm-sim-3, results = 'hide'}
# Get locations from simulated step lengths and turning angles
bearings <- cumsum(sim_data$angle)
sim_dxy <- sim_data$step * cbind(cos(bearings), sin(bearings))
sim_data$x <- cumsum(c(0, sim_dxy[-n_sim, 1]))
sim_data$y <- cumsum(c(0, sim_dxy[-n_sim, 2]))

# Plot simulated trajectory
ggplot(sim_data, aes(x, y, col = factor(state), group = NA)) + 
  scale_color_manual("State", values = hmmTMB_cols) +
  geom_point(size = 0.7) + 
  geom_path() +
  coord_equal()
```

# References
