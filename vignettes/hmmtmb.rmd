---
title: "hmmTMB vignette"
author: "Richard Glennie, ThÃ©o Michelot"
date: "`r Sys.Date()`"
output: rmarkdown::html_document
vignette: >
  %\VignetteIndexEntry{hmmTMB vignette}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  message = FALSE, error = FALSE, warning = FALSE,
  comment = NA
)
```

```{r load-package, echo = FALSE}
library(hmmTMB)
set.seed(342)
```

# Observation distribution

Distributions for the observation process are created using the Dist class. To define a new distribution, we provide its name (as a string), its probability density/mass function (as a function), and the link functions for its parameters (as named lists of functions). For example, for the normal distribution, we have
```{r dist-def}
dist_norm <- Dist$new(
  name = "norm", 
  pdf = dnorm,
  link = list(mean = identity, sd = log),
  invlink = list(mean = identity, sd = exp),
  npar = 2
)
```

The Poisson, gamma, normal, beta, and von Mises distributions are included in the package, and more will be implemented in the future.

The functions n2w and w2n transform parameters of the observation distributions from the natural to the working scale and vice-versa. We can verify that applying the two functions successively returns the original parameter values:
```{r norm-test}
# List of parameters (on the natural scale)
par1 <- list(mean = c(0, 5), sd = c(1, 10))

# Transform to working scale
wpar <- dist_norm$n2w(par1)
wpar

# Transform back to natural scale
par2 <- dist_norm$w2n(wpar)
par2
```

# HMM data

Data objects are defined with the HmmData class. An object can be created from a data frame which includes one column for each observed variable and for each covariate. There are special column names: "ID" is used to identify the time series if several are provided, and "time" gives the times of observation. If the times of observations are provided, gaps are automatically filled with NAs to create a obtain a regular time grid.

```{r create-data}
# Create a dummy data set, with two time series
times1 <- seq(as.POSIXct("2020/01/01 00:00:00"), by = "hour", length = 10)
times2 <- seq(as.POSIXct("2020/02/01 00:00:00"), by = "hour", length = 10)
data <- data.frame(ID = rep(c(1, 2), each = 10),
                   x = rnorm(20), 
                   time = c(times1, times2))

# Remove a few rows to create gaps in the data
data <- data[-c(2:3, 7, 15:18),]

# Define HmmData object
data_prep <- HmmData$new(data = data, interval = "hour")

# The gaps have been filled
data_prep$data()
```

# HMM observation model

The class Observation encapsulates the model for the observed variables.

```{r obs-create}
# Create a dummy data set
times <- seq(as.POSIXct("2020/01/01 00:00:00"), by = "hour", length = 100)
data <- data.frame(ID = rep(1, 100),
                   x = rnorm(100), 
                   time = times)
data_prep <- HmmData$new(data = data)

# List of observation distributions
dists <- list(x = dist_norm)

# List of observation parameters
par <- list(x = list(mean = c(0, 0), sd = c(1, 10)))

# Number of states
n_states <- 2

# Create observation process object
obs_process <- Observation$new(data = data_prep, dists = dists, 
                               n_states = n_states, par = par)
```

The parameters on the working scale are calculated when the object is created:
```{r obs-wpar}
obs_process$wpar()
```

The function plot_dist generates a histogram of the observations with the probability density (or mass) function of the specified distribution.
```{r obs-plot}
# Plot histogram and pdf for variable "x"
obs_process$plot_dist(name = "x")
```

## User-specified observation distribution

_Here we will need to explain how additional distributions can be added by users._

## Example of use

We illustrate the use of the package on a data set of elk movement (from Morales et al., 2004, Ecology), accessible through the moveHMM package.

```{r load-packs}
# Load packages
library(hmmTMB)
library(moveHMM)
```


In analyses of animal movement, the step lengths and turning angles are modelled to capture features of the speed and directionality of the movement. We derive those variables from the location using the function prepData in moveHMM.

```{r prep-data}
tracks <- prepData(elk_data, type = "UTM", coordNames = c("Easting", "Northing"))

head(tracks)
```

The data set now has columns for the coordinates (x and y), the step lengths and turning angles, the ID (track identifier), and a covariate (distance to water). hmmTMB doesn't allow for zero inflation for observation distributions with positive support (e.g. gamma), so we jitter step lengths with value zero.

```{r jitter}
indz <- which(tracks$step == 0)
tracks$step[indz] <- runif(length(indz), 0, 1)
```

We create an HmmData object from the data frame. It should include columns for ID if necessary, as well as for any response variables and covariates included in the model.
```{r hmmdata-new}
data <- HmmData$new(data = tracks)
```

The class Observation encapsulates the observation process model of the hidden Markov model. To create an object of that class, we need to specify distributions for the response variables, as well as initial parameter values. We could also include covariate dependence in the parameters of the observation distributions. We use gamma distributions for the step lengths, and von Mises distributions for the turning angles.

```{r obs-new}
# Number of states of the HMM 
n_states <- 2

# Observation distributions: gamma for the step lengths, and
# von Mises for the turning angles
dists <- list(step = dist_gamma, angle = dist_vm)

# Initial parameters
mean0 <- c(300, 3000)
sd0 <- c(400, 4000)
par0_obs <- list(step = list(shape = mean0^2/sd0^2,
                             scale = sd0^2/mean0),
                 angle = list(mu = c(3, 0),
                              kappa = c(0.2, 1)))

# Create Observation object
obs <- Observation$new(data = data, dists = dists, 
                       n_states = n_states, par = par0_obs)
```

Similarly, we need to create an object of the class MarkovChain for the hidden process model, encapsulating the formulas and parameter values. Here, we formulate the transition probabilities as functions of the distance to water covariate.

```{r hid-new}
# Formula for transition probabilities
formula <- "~ dist_water"

# Initial parameters on working scale, chosen for dominant diagonal terms, and
# no covariate effects
par0_hid <- c(-2, 0, -2, 0)
hid <- MarkovChain$new(n_states = n_states, 
                       structure = formula,
                       par = par0_hid)
```

Combining the MarkovChain and Observation object, we create an object of the Hmm class.

```{r hmm-new}
hmm <- Hmm$new(obs = obs, hidden = hid)
```

We fit the model with the method fit, and print the output of the optimiser with res.

```{r hmm-fit}
hmm$fit()

hmm$res()
```

The method viterbi implements the Viterbi algorithm, to estimate the most likely state sequence.
```{r hmm-viterbi}
states <- hmm$viterbi()

head(states)
```

Various plotting functions are provided to visualise a fitted model. Using the method Observation\$plot_dist, we can plot histograms of the observed data, overlaid with the estimated state-dependent probability density functions.

```{r plot-dist}
# Proportion of states in Viterbi sequence, to weigh pdfs
w <- table(states)/length(states)
obs$plot_dist("step", weights = w)
obs$plot_dist("angle", weights = w)
```

We can plot the data coloured by the Viterbi-decoded states.

```{r plot-ts}
hmm$plot_ts("step")
hmm$plot_ts("x", "y") + coord_equal() + geom_point(size = 0.3)
```

There is no dedicated function yet, but the model outputs can be used to plot the transition probabilities as functions of the covariate.

```{r plot-tpm}
new_data <- data.frame(dist_water = seq(0, 4000, length = 1e3))
mats <- hid$make_mat(data = new_data)
tpms <- hid$tpm_all(X_fe = mats$X_fe, X_re = mats$X_re)
par(mfrow = c(2, 2))
for(i in 1:2) {
  for(j in 1:2) {
    plot(tpms[i,j,], type = "l", xlab = "dist_water", ylab = paste(i, "->", j), 
         ylim = c(0, 1))
  }
}
```

## Future work

 - AIC
 
 - confidence intervals
    + on natural parameters
    + on transformed quantities (e.g. covariate-dependent parameters)
    + run simulation experiments to check coverage
 
 - pseudo-residuals
 
 - stationary state probabilities as functions of covariates
 
 - state probabilities (local decoding)
 
 - additional observation distributions
    + Weibull
    + log-normal
    + wrapped Cauchy
    + Bernoulli...
    
 - zero inflation
 
 - improve parametrisation of mean of circular distributions (avoid numerical issues around -pi and pi)
 
 - allow for input of known states (semi-supervised learning)
 
 - allow for constraints on parameters
    + inequalities, e.g. $\mu_1 < \mu_2$
    + bounds, e.g. $-1 < \mu_1 < 1$
    + fixed value, e.g. $\mu_1 = 0$
    
 - obtain starting values for complex models from simpler nested model (e.g. for smooth effects)
 
 - plotting functions to visualise fitted model
    + time series coloured by states
    + covariate effects...
    
 - update/create documentation for class methods and attributes
 
 - informative error messages in constructors
 
 - deal with NAs in covariates (linear interpolation? nearest value? error message?)
 
 - simulation function, to simulate either from a fitted model or based
 on parameter values given as input. Method of Hmm class?
 
 - stationary = TRUE/FALSE option in MarkovChain class
 